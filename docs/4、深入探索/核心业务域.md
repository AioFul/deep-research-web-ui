# 核心业务域技术实现文档

## 1. 概述

核心业务域是AI驱动深度研究和分析系统的核心逻辑处理层，承担着系统最重要的业务功能实现。该域主要负责深度研究算法、反馈生成、递归搜索等核心业务逻辑，协调AI服务域、网络搜索域等基础设施域完成具体业务需求。

### 1.1 域定位与职责

- **主要职责**：实现AI驱动的递归网络搜索和分析系统
- **核心功能**：深度研究、反馈生成、报告生成
- **重要性评分**：10.0（最高级别）
- **复杂度评分**：9.0（高复杂度）

### 1.2 域内模块构成

核心业务域包含以下子模块：

1. **深度研究模块** (`lib/core/deep-research.ts`) - 实现递归搜索和分析
2. **反馈生成模块** (`lib/core/feedback.ts`) - 生成AI驱动的反馈问题
3. **报告生成模块** (`lib/core/deep-research.ts`) - 整合结果并生成报告

## 2. 深度研究模块技术实现

### 2.1 模块概述

深度研究模块是系统的核心组件，实现了AI驱动的递归网络搜索和分析系统。该模块支持多语言、错误处理、进度跟踪和并发控制，适用于需要深入研究复杂问题的场景。

### 2.2 核心实现机制

#### 2.2.1 递归树状结构

模块采用递归树状结构实现深度研究，通过 `breadth` 和 `maxDepth` 参数控制搜索的广度和深度：

```typescript
// 递归搜索的核心逻辑
async function recursiveResearch(
  query: string,
  depth: number,
  maxDepth: number,
  breadth: number,
  onProgress?: (progress: ResearchProgress) => void
): Promise<ResearchNode> {
  // 生成搜索查询
  const searchQueries = await generateSearchQueries(query);
  
  // 并发控制执行搜索
  const searchResults = await executeSearches(searchQueries, breadth);
  
  // 处理搜索结果
  const processedResults = await processSearchResults(searchResults);
  
  // 提取学习点和后续问题
  const { learningPoints, followupQuestions } = await extractInsights(processedResults);
  
  // 递归处理后续问题（如果未达到最大深度）
  if (depth < maxDepth && followupQuestions.length > 0) {
    const childNodes = await Promise.all(
      followupQuestions.slice(0, breadth).map(followupQuery => 
        recursiveResearch(followupQuery, depth + 1, maxDepth, breadth, onProgress)
      )
    );
    
    return {
      query,
      learningPoints,
      children: childNodes,
      depth
    };
  }
  
  return {
    query,
    learningPoints,
    children: [],
    depth
  };
}
```

#### 2.2.2 并发控制机制

使用 `pLimit` 库进行并发控制，限制同时执行的搜索请求数量：

```typescript
import pLimit from 'p-limit';

const limit = pLimit(3); // 限制并发数为3

async function executeSearches(queries: string[], maxConcurrency: number) {
  const limit = pLimit(maxConcurrency);
  const results = await Promise.all(
    queries.map(query => limit(() => searchFunction(query)))
  );
  return results;
}
```

#### 2.2.3 数据验证机制

使用 Zod-to-json-schema 进行数据验证，确保输入输出数据的格式正确性：

```typescript
import { z } from 'zod';

const ResearchResultSchema = z.object({
  query: z.string(),
  learningPoints: z.array(z.string()),
  followupQuestions: z.array(z.string()),
  sources: z.array(z.object({
    title: z.string(),
    url: z.string().url(),
    content: z.string()
  }))
});

type ResearchResult = z.infer<typeof ResearchResultSchema>;
```

#### 2.2.4 流式响应处理

通过 `parseStreamingJson` 处理AI模型的流式响应：

```typescript
async function processStreamResponse(stream: ReadableStream) {
  const reader = stream.getReader();
  let buffer = '';
  
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    buffer += new TextDecoder().decode(value);
    
    // 解析流式JSON响应
    const parsed = parseStreamingJson(buffer);
    if (parsed) {
      onProgress?.(parsed);
    }
  }
}
```

### 2.3 错误处理机制

模块实现了完善的错误处理机制，对每个节点的错误进行单独处理：

```typescript
async function safeExecute<T>(
  operation: () => Promise<T>,
  fallbackValue: T,
  onError?: (error: Error) => void
): Promise<T> {
  try {
    return await operation();
  } catch (error) {
    console.error('Operation failed:', error);
    onError?.(error as Error);
    return fallbackValue;
  }
}
```

### 2.4 进度跟踪功能

通过 `onProgress` 回调函数传递研究进度：

```typescript
interface ResearchProgress {
  currentDepth: number;
  maxDepth: number;
  completedQueries: number;
  totalQueries: number;
  currentQuery: string;
  status: 'searching' | 'analyzing' | 'processing' | 'completed';
}

async function deepResearch(
  query: string,
  options: ResearchOptions,
  onProgress?: (progress: ResearchProgress) => void
): Promise<ResearchResult> {
  // 实现进度跟踪逻辑
}
```

## 3. 反馈生成模块技术实现

### 3.1 模块概述

反馈生成模块负责基于用户查询生成相关后续问题，帮助用户明确研究方向。系统通过AI模型分析用户输入的问题，生成一系列相关的反馈问题供用户选择。

### 3.2 核心实现

```typescript
async function generateFeedbackQuestions(
  query: string,
  context?: string
): Promise<FeedbackQuestions> {
  const prompt = generateFeedbackPrompt(query, context);
  
  const response = await aiProvider.generateText({
    prompt,
    model: 'gpt-4',
    maxTokens: 500
  });
  
  return parseFeedbackResponse(response);
}

function generateFeedbackPrompt(query: string, context?: string): string {
  return `
    基于以下研究问题，生成5-10个相关的后续研究问题：
    主要问题: ${query}
    ${context ? `上下文: ${context}` : ''}
    
    请确保问题具有研究价值且与主问题相关。
  `;
}
```

## 4. 报告生成模块技术实现

### 4.1 模块概述

报告生成模块负责整合研究结果并生成详细研究报告。该模块将递归搜索得到的树状结构数据转换为结构化、可读性强的研究报告。

### 4.2 报告结构设计

```typescript
interface ResearchReport {
  title: string;
  summary: string;
  methodology: string;
  findings: ResearchFinding[];
  sources: Source[];
  timeline: ResearchTimeline;
  conclusion: string;
}

interface ResearchFinding {
  depth: number;
  query: string;
  learningPoints: string[];
  supportingEvidence: Evidence[];
  relatedQuestions: string[];
}
```

### 4.3 报告生成流程

```typescript
async function generateFinalReport(
  researchTree: ResearchNode,
  options: ReportOptions
): Promise<ResearchReport> {
  // 1. 提取所有研究节点
  const allNodes = flattenResearchTree(researchTree);
  
  // 2. 生成摘要
  const summary = await generateSummary(allNodes);
  
  // 3. 整理发现点
  const findings = organizeFindings(allNodes);
  
  // 4. 收集来源
  const sources = collectSources(allNodes);
  
  // 5. 生成结论
  const conclusion = await generateConclusion(findings);
  
  return {
    title: options.title || 'Research Report',
    summary,
    findings,
    sources,
    conclusion,
    methodology: 'AI-driven Recursive Research',
    timeline: generateTimeline(researchTree)
  };
}
```

## 5. 模块间协作机制

### 5.1 与AI服务域的协作

核心业务域通过以下方式与AI服务域协作：

1. **搜索查询生成**：调用AI模型生成搜索查询
2. **结果分析**：使用AI模型分析搜索结果
3. **报告撰写**：利用AI模型生成最终报告

```typescript
// 与AI服务域的接口调用
import { aiProvider } from '@/lib/ai/providers';
import { generateSystemPrompt } from '@/lib/prompt';

const systemPrompt = generateSystemPrompt('research');
const response = await aiProvider.generateText({
  prompt: userQuery,
  system: systemPrompt,
  model: config.aiModel,
  stream: true
});
```

### 5.2 与网络搜索域的协作

通过 `webSearchFunction` 接口与网络搜索域协作：

```typescript
interface WebSearchFunction {
  (query: string, options?: SearchOptions): Promise<SearchResult[]>;
}

async function executeSearch(query: string): Promise<SearchResult[]> {
  return await webSearchFunction(query, {
    maxResults: 5,
    searchDepth: 'advanced'
  });
}
```

### 5.3 与配置管理域的协作

从配置管理域获取运行时配置：

```typescript
import { useConfigStore } from '@/stores/config';

const config = useConfigStore();
const researchOptions = {
  aiModel: config.selectedModel,
  searchProvider: config.searchProvider,
  maxDepth: config.maxResearchDepth,
  concurrency: config.maxConcurrency
};
```

## 6. 性能优化策略

### 6.1 缓存机制

实现结果缓存以避免重复计算：

```typescript
const researchCache = new Map<string, ResearchResult>();

function getCachedResult(key: string): ResearchResult | undefined {
  return researchCache.get(key);
}

function setCacheResult(key: string, result: ResearchResult): void {
  researchCache.set(key, result);
}
```

### 6.2 内存管理

对大型研究结果进行分页处理：

```typescript
interface PagedResearchResult {
  currentPage: number;
  totalPages: number;
  pageSize: number;
  data: ResearchResult[];
  totalNodes: number;
}
```

## 7. 扩展性设计

### 7.1 插件化架构

支持扩展新的研究算法和分析方法：

```typescript
interface ResearchStrategy {
  name: string;
  execute: (query: string, options: ResearchOptions) => Promise<ResearchResult>;
  supports: (feature: string) => boolean;
}

class ResearchEngine {
  private strategies: Map<string, ResearchStrategy> = new Map();
  
  registerStrategy(strategy: ResearchStrategy): void {
    this.strategies.set(strategy.name, strategy);
  }
  
  async execute(query: string, strategyName: string): Promise<ResearchResult> {
    const strategy = this.strategies.get(strategyName);
    if (!strategy) throw new Error(`Unknown strategy: ${strategyName}`);
    return await strategy.execute(query, this.options);
  }
}
```

### 7.2 配置驱动

通过配置文件支持不同的研究模式：

```typescript
interface ResearchConfig {
  mode: 'comprehensive' | 'focused' | 'quick';
  depth: number;
  breadth: number;
  aiProvider: string;
  searchProvider: string;
  outputFormat: 'json' | 'markdown' | 'pdf';
}
```

## 8. 总结

核心业务域作为AI驱动深度研究系统的核心，通过递归搜索、并发控制、流式处理等先进技术实现了复杂问题的深度分析。模块设计充分考虑了可扩展性、性能优化和错误处理，为系统提供了强大的研究能力支撑。通过与AI服务域、网络搜索域等基础设施域的紧密协作，实现了完整的AI驱动研究流程。